Author: IOhannes m zm√∂lnig
Forward: http://sourceforge.net/tracker/?func=detail&aid=2989552&group_id=55736&atid=478072
Description: replace use of type-punned pointers with unions to avoid breaking
of strict alias rules;
"-O2" optimization (which is used for compiling pd) enables "-fstrict-aliasing"
in gcc, which (potentially) breaks Pd's byte-fuddling with pointer-casts like
(*(unsigned int*)&(float)); this patch removes these casts and replaces them by
proper accesses to float/int unions.
--- puredata.orig/src/d_math.c
+++ puredata/src/d_math.c
@@ -98,20 +98,26 @@
 
 t_float q8_rsqrt(t_float f0)
 {
-    float f = (float)f0;
-    long l = *(long *)(&f);
-    if (f < 0) return (0);
-    else return (rsqrt_exptab[(l >> 23) & 0xff] *
-            rsqrt_mantissatab[(l >> 13) & 0x3ff]);
+    union {
+      float f;
+      long l;
+    } u;
+    u.f=f0;
+    if (u.f < 0) return (0);
+    else return (rsqrt_exptab[(u.l >> 23) & 0xff] *
+            rsqrt_mantissatab[(u.l >> 13) & 0x3ff]);
 }
 
 t_float q8_sqrt(t_float f0)
 {
-    float f = (float)f0;
-    long l = *(long *)(&f);
-    if (f < 0) return (0);
-    else return (f * rsqrt_exptab[(l >> 23) & 0xff] *
-            rsqrt_mantissatab[(l >> 13) & 0x3ff]);
+    union {
+      float f;
+      long l;
+    } u;
+    u.f=f0;
+    if (u.f < 0) return (0);
+    else return (u.f * rsqrt_exptab[(u.l >> 23) & 0xff] *
+            rsqrt_mantissatab[(u.l >> 13) & 0x3ff]);
 }
 
     /* the old names are OK unless we're in IRIX N32 */
--- puredata.orig/src/m_pd.h
+++ puredata/src/m_pd.h
@@ -64,9 +64,24 @@
 #if !defined(PD_LONGINTTYPE)
 #define PD_LONGINTTYPE long
 #endif
-#if !defined(PD_FLOATTYPE)
-#define PD_FLOATTYPE float
+
+#if !defined(PD_FLOATSIZE)
+  /* normally, our floats (t_float, t_sample,...) are 32bit */
+# define PD_FLOATSIZE 32
 #endif
+
+#if PD_FLOATSIZE == 32
+# define PD_FLOATTYPE float
+/* an unsigned int of the same size as FLOATTYPE: */
+# define PD_FLOATUINTTYPE unsigned int
+
+#elif PD_FLOATSIZE == 64
+# define PD_FLOATTYPE double
+# define PD_FLOATUINTTYPE unsigned long
+#else
+# error invalid FLOATSIZE: must be 32 or 64
+#endif
+
 typedef PD_LONGINTTYPE t_int;       /* pointer-size integer */
 typedef PD_FLOATTYPE t_float;       /* a float type at most the same size */
 typedef PD_FLOATTYPE t_floatarg;    /* float type for function calls */
@@ -489,6 +504,10 @@
 /* --------------- signals ----------------------------------- */
 
 typedef PD_FLOATTYPE t_sample;
+typedef union _sampleint_union {
+  t_sample f;
+  PD_FLOATUINTTYPE i;
+} t_sampleint_union;
 #define MAXLOGSIG 32
 #define MAXSIGSIZE (1 << MAXLOGSIG)
 
@@ -641,14 +660,26 @@
 
 #if defined(__i386__) || defined(__x86_64__)
 /* a test for NANs and denormals.  Should only be necessary on i386. */
-#define PD_BADFLOAT(f) ((((*(unsigned int*)&(f))&0x7f800000)==0) || \
-    (((*(unsigned int*)&(f))&0x7f800000)==0x7f800000))
+# if PD_FLOATSIZE == 32
+static inline int PD_BADFLOAT(t_sample f) {
+  t_sampleint_union u;
+  u.f=f;
+  return ((u.i & 0x7f800000)==0) || ((u.i&0x7f800000)==0x7f800000);
+}
 /* more stringent test: anything not between 1e-19 and 1e19 in absolute val */
-#define PD_BIGORSMALL(f) ((((*(unsigned int*)&(f))&0x60000000)==0) || \
-    (((*(unsigned int*)&(f))&0x60000000)==0x60000000))
+static inline int PD_BIGORSMALL(t_sample f) {
+  t_sampleint_union u;
+  u.f=f;
+  return ((u.i & 0x60000000)==0) || ((u.i & 0x60000000)==0x60000000);
+}
+# else
+#  warning 64bit mode: BIGORSMALL not implemented yet
+#  define PD_BADFLOAT(f) 0
+#  define PD_BIGORSMALL(f) 0
+# endif
 #else
-#define PD_BADFLOAT(f) 0
-#define PD_BIGORSMALL(f) 0
+# define PD_BADFLOAT(f) 0
+# define PD_BIGORSMALL(f) 0
 #endif
 
     /* get version number at run time */
--- puredata.orig/src/d_soundfile.c
+++ puredata/src/d_soundfile.c
@@ -41,6 +41,11 @@
 typedef unsigned short uint16;
 typedef unsigned int uint32;
 
+typedef union _samplelong {
+  t_sample f;
+  long     l;
+} t_sampleuint;
+
 #define FORMAT_WAVE 0
 #define FORMAT_AIFF 1
 #define FORMAT_NEXT 2
@@ -246,12 +251,12 @@
         swap = (bigendian != garray_ambigendian());
         if (format == FORMAT_NEXT)   /* nextstep header */
         {
-            uint32 param;
+            t_nextstep*nsbuf=(t_nextstep *)buf;
             if (bytesread < (int)sizeof(t_nextstep))
                 goto badheader;
-            nchannels = swap4(((t_nextstep *)buf)->ns_nchans, swap);
-            format = swap4(((t_nextstep *)buf)->ns_format, swap);
-            headersize = swap4(((t_nextstep *)buf)->ns_onset, swap);
+            nchannels = swap4(nsbuf->ns_nchans, swap);
+            format = swap4(nsbuf->ns_format, swap);
+            headersize = swap4(nsbuf->ns_onset, swap);
             if (format == NS_FORMAT_LINEAR_16)
                 bytespersamp = 2;
             else if (format == NS_FORMAT_LINEAR_24)
@@ -263,6 +268,7 @@
         }
         else if (format == FORMAT_WAVE)     /* wave header */
         {
+               t_wavechunk*wavechunk=(t_wavechunk *)buf;
                /*  This is awful.  You have to skip over chunks,
                except that if one happens to be a "fmt" chunk, you want to
                find out the format from that one.  The case where the
@@ -282,13 +288,13 @@
                     ((t_wavechunk *)buf)->wc_id[2],
                     ((t_wavechunk *)buf)->wc_id[3]); */
                 /* read chunks in loop until we get to the data chunk */
-            while (strncmp(((t_wavechunk *)buf)->wc_id, "data", 4))
+            while (strncmp(wavechunk->wc_id, "data", 4))
             {
-                long chunksize = swap4(((t_wavechunk *)buf)->wc_size,
+                long chunksize = swap4(wavechunk->wc_size,
                     swap), seekto = headersize + chunksize + 8, seekout;
                 if (seekto & 1)     /* pad up to even number of bytes */
                     seekto++;                
-                if (!strncmp(((t_wavechunk *)buf)->wc_id, "fmt ", 4))
+                if (!strncmp(wavechunk->wc_id, "fmt ", 4))
                 {
                     long commblockonset = headersize + 8;
                     seekout = lseek(fd, commblockonset, SEEK_SET);
@@ -313,18 +319,19 @@
                     (int) sizeof(t_wavechunk))
                         goto badheader;
                 /* post("new chunk %c %c %c %c at %d",
-                    ((t_wavechunk *)buf)->wc_id[0],
-                    ((t_wavechunk *)buf)->wc_id[1],
-                    ((t_wavechunk *)buf)->wc_id[2],
-                    ((t_wavechunk *)buf)->wc_id[3], seekto); */
+                    wavechunk->wc_id[0],
+                    wavechunk->wc_id[1],
+                    wavechunk->wc_id[2],
+                    wavechunk->wc_id[3], seekto); */
                 headersize = seekto;
             }
-            bytelimit = swap4(((t_wavechunk *)buf)->wc_size, swap);
+            bytelimit = swap4(wavechunk->wc_size, swap);
             headersize += 8;
         }
         else
         {
                 /* AIFF.  same as WAVE; actually predates it.  Disgusting. */
+            t_datachunk*datachunk;
             headersize = 12;
             if (bytesread < 20)
                 goto badheader;
@@ -335,28 +342,31 @@
                 /* copy the first chunk header to beginnning of buffer. */
             memcpy(buf, buf + headersize, sizeof(t_datachunk));
                 /* read chunks in loop until we get to the data chunk */
-            while (strncmp(((t_datachunk *)buf)->dc_id, "SSND", 4))
+            datachunk=(t_datachunk*)buf;
+            while (strncmp(datachunk->dc_id, "SSND", 4))
             {
-                long chunksize = swap4(((t_datachunk *)buf)->dc_size,
+                long chunksize = swap4(datachunk->dc_size,
                     swap), seekto = headersize + chunksize + 8, seekout;
                 if (seekto & 1)     /* pad up to even number of bytes */
                     seekto++;
                 /* post("chunk %c %c %c %c seek %d",
-                    ((t_datachunk *)buf)->dc_id[0],
-                    ((t_datachunk *)buf)->dc_id[1],
-                    ((t_datachunk *)buf)->dc_id[2],
-                    ((t_datachunk *)buf)->dc_id[3], seekto); */
-                if (!strncmp(((t_datachunk *)buf)->dc_id, "COMM", 4))
+                    datachunk->dc_id[0],
+                    datachunk->dc_id[1],
+                    datachunk->dc_id[2],
+                    datachunk->dc_id[3], seekto); */
+                if (!strncmp(datachunk->dc_id, "COMM", 4))
                 {
                     long commblockonset = headersize + 8;
+                    t_comm*commchunk;
                     seekout = lseek(fd, commblockonset, SEEK_SET);
                     if (seekout != commblockonset)
                         goto badheader;
                     if (read(fd, buf, sizeof(t_comm)) <
                         (int) sizeof(t_comm))
                             goto badheader;
-                    nchannels = swap2(((t_comm *)buf)->c_nchannels, swap);
-                    format = swap2(((t_comm *)buf)->c_bitspersamp, swap);
+                    commchunk=(t_comm *)buf;
+                    nchannels = swap2(commchunk->c_nchannels, swap);
+                    format = swap2(commchunk->c_bitspersamp, swap);
                     if (format == 16)
                         bytespersamp = 2;
                     else if (format == 24)
@@ -371,7 +381,7 @@
                         goto badheader;
                 headersize = seekto;
             }
-            bytelimit = swap4(((t_datachunk *)buf)->dc_size, swap) - 8;
+            bytelimit = swap4(datachunk->dc_size, swap) - 8;
             headersize += sizeof(t_datachunk);
         }
     }
@@ -910,7 +920,6 @@
     unsigned char *sp, *sp2;
     t_sample *fp;
     int bytesperframe = bytespersamp * nchannels;
-    long xx;
     for (i = 0, sp = buf; i < nchannels; i++, sp += bytespersamp)
     {
         if (bytespersamp == 2)
@@ -990,10 +999,10 @@
                 for (j = 0, sp2 = sp, fp=vecs[i] + onset;
                     j < nitems; j++, sp2 += bytesperframe, fp += spread)
                 {
-                    t_sample f2 = *fp * normalfactor;
-                    xx = *(long *)&f2;
-                    sp2[0] = (xx >> 24); sp2[1] = (xx >> 16);
-                    sp2[2] = (xx >> 8); sp2[3] = xx;
+                    t_sampleuint f2;
+                    f2.f = *fp * normalfactor;
+                    sp2[0] = (f2.l >> 24); sp2[1] = (f2.l >> 16);
+                    sp2[2] = (f2.l >> 8); sp2[3] = f2.l;
                 }
             }
             else
@@ -1001,10 +1010,10 @@
                 for (j = 0, sp2 = sp, fp=vecs[i] + onset;
                     j < nitems; j++, sp2 += bytesperframe, fp += spread)
                 {
-                    t_sample f2 = *fp * normalfactor;
-                    xx = *(long *)&f2;
-                    sp2[3] = (xx >> 24); sp2[2] = (xx >> 16);
-                    sp2[1] = (xx >> 8); sp2[0] = xx;
+                    t_sampleuint f2;
+                    f2.f = *fp * normalfactor;
+                    sp2[3] = (f2.l >> 24); sp2[2] = (f2.l >> 16);
+                    sp2[1] = (f2.l >> 8); sp2[0] = f2.l;
                 }
             }
         }
@@ -1018,7 +1027,6 @@
     unsigned char *sp, *sp2;
     t_float *fp;
     int bytesperframe = bytespersamp * nchannels;
-    long xx;
     for (i = 0, sp = buf; i < nchannels; i++, sp += bytespersamp)
     {
         if (bytespersamp == 2)
@@ -1098,10 +1106,10 @@
                 for (j = 0, sp2 = sp, fp=vecs[i] + onset;
                     j < nitems; j++, sp2 += bytesperframe, fp += spread)
                 {
-                    t_sample f2 = *fp * normalfactor;
-                    xx = *(long *)&f2;
-                    sp2[0] = (xx >> 24); sp2[1] = (xx >> 16);
-                    sp2[2] = (xx >> 8); sp2[3] = xx;
+                    t_sampleuint f2;
+                    f2.f = *fp * normalfactor;
+                    sp2[0] = (f2.l >> 24); sp2[1] = (f2.l >> 16);
+                    sp2[2] = (f2.l >> 8); sp2[3] = f2.l;
                 }
             }
             else
@@ -1109,10 +1117,10 @@
                 for (j = 0, sp2 = sp, fp=vecs[i] + onset;
                     j < nitems; j++, sp2 += bytesperframe, fp += spread)
                 {
-                    t_sample f2 = *fp * normalfactor;
-                    xx = *(long *)&f2;
-                    sp2[3] = (xx >> 24); sp2[2] = (xx >> 16);
-                    sp2[1] = (xx >> 8); sp2[0] = xx;
+                    t_sampleuint f2;
+                    f2.f = *fp * normalfactor;
+                    sp2[3] = (f2.l >> 24); sp2[2] = (f2.l >> 16);
+                    sp2[1] = (f2.l >> 8); sp2[0] = f2.l;
                 }
             }
         }
